{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "7983bc7f-8747-43a1-872f-4d1d8ec29d81",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "2024-12-01 15:26:14.461 \n",
      "  \u001b[33m\u001b[1mWarning:\u001b[0m to view this Streamlit app on a browser, run it with the following\n",
      "  command:\n",
      "\n",
      "    streamlit run C:\\Users\\Sachin D B\\AppData\\Roaming\\Python\\Python312\\site-packages\\ipykernel_launcher.py [ARGUMENTS]\n"
     ]
    }
   ],
   "source": [
    "# Required Libraries\n",
    "import streamlit as st\n",
    "import numpy as np\n",
    "from scipy.stats import norm\n",
    "from scipy.optimize import minimize\n",
    "from nsetools import Nse\n",
    "import pandas as pd\n",
    "import yfinance as yf\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# Initialize NSE Tool\n",
    "nse = Nse()\n",
    "\n",
    "# Black-Scholes Formula\n",
    "def black_scholes(S, K, T, r, sigma, option_type=\"call\"):\n",
    "    d1 = (np.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * np.sqrt(T))\n",
    "    d2 = d1 - sigma * np.sqrt(T)\n",
    "    if option_type == \"call\":\n",
    "        price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n",
    "    elif option_type == \"put\":\n",
    "        price = K * np.exp(-r * T) * norm.cdf(-d2) - S * norm.cdf(-d1)\n",
    "    else:\n",
    "        raise ValueError(\"Option type must be 'call' or 'put'\")\n",
    "    return price\n",
    "\n",
    "# Implied Volatility Calculation\n",
    "def implied_volatility(S, K, T, r, market_price, option_type):\n",
    "    def bs_price_with_vol(sigma):\n",
    "        return black_scholes(S, K, T, r, sigma, option_type)\n",
    "\n",
    "    def loss(sigma):\n",
    "        return (bs_price_with_vol(sigma) - market_price) ** 2\n",
    "\n",
    "    initial_sigma = 0.2\n",
    "    result = minimize(loss, initial_sigma, bounds=[(1e-5, 5.0)])\n",
    "    return result.x[0] if result.success else None\n",
    "\n",
    "# Fetch Option Chain\n",
    "def fetch_option_chain(ticker):\n",
    "    try:\n",
    "        option_chain = nse.get_option_chain(ticker)\n",
    "        data = option_chain['records']['data']\n",
    "        calls, puts = [], []\n",
    "        for item in data:\n",
    "            calls.append(item['CE']) if 'CE' in item else None\n",
    "            puts.append(item['PE']) if 'PE' in item else None\n",
    "        call_df = pd.DataFrame(calls)\n",
    "        put_df = pd.DataFrame(puts)\n",
    "        return call_df, put_df\n",
    "    except Exception as e:\n",
    "        st.error(f\"Failed to fetch option chain: {e}\")\n",
    "        return None, None\n",
    "\n",
    "# Streamlit App\n",
    "st.title(\"Indian Market Black-Scholes Calculator\")\n",
    "st.sidebar.header(\"Input Parameters\")\n",
    "\n",
    "# User Inputs\n",
    "ticker = st.sidebar.text_input(\"Stock Ticker (NSE)\", value=\"RELIANCE\")\n",
    "K = st.sidebar.number_input(\"Strike Price (K)\", min_value=0.0, value=2500.0, step=10.0)\n",
    "T_days = st.sidebar.number_input(\"Days to Maturity\", min_value=1, value=30, step=1)\n",
    "r = st.sidebar.number_input(\"Risk-Free Rate (%)\", min_value=0.0, value=6.5, step=0.1) / 100\n",
    "sigma = st.sidebar.number_input(\"Volatility (%)\", min_value=0.0, value=20.0, step=0.1) / 100\n",
    "option_type = st.sidebar.radio(\"Option Type\", (\"call\", \"put\"))\n",
    "\n",
    "# Fetch live stock price\n",
    "st.subheader(f\"Fetching live data for {ticker.upper()}...\")\n",
    "try:\n",
    "    stock_data = yf.Ticker(f\"{ticker}.NS\")\n",
    "    S = stock_data.history(period=\"1d\")[\"Close\"].iloc[-1]\n",
    "    st.write(f\"**Current Stock Price (S): ₹{S:.2f}**\")\n",
    "except:\n",
    "    st.error(\"Unable to fetch live data. Check ticker or internet connection.\")\n",
    "    S = st.sidebar.number_input(\"Manual Stock Price (₹)\", min_value=0.0, value=2500.0, step=10.0)\n",
    "\n",
    "# Convert T from days to years\n",
    "T = T_days / 365\n",
    "\n",
    "# Calculate Option Price\n",
    "option_price = black_scholes(S, K, T, r, sigma, option_type)\n",
    "\n",
    "# Display Results\n",
    "st.subheader(\"Option Price\")\n",
    "st.write(f\"The **{option_type.capitalize()} Option Price** is: ₹{option_price:.2f}\")\n",
    "\n",
    "# Payoff Graph\n",
    "st.subheader(\"Option Payoff Chart\")\n",
    "stock_prices = np.linspace(S * 0.5, S * 1.5, 100)\n",
    "payoff = np.maximum(stock_prices - K, 0) if option_type == \"call\" else np.maximum(K - stock_prices, 0)\n",
    "plt.figure(figsize=(10, 5))\n",
    "plt.plot(stock_prices, payoff, label=f\"{option_type.capitalize()} Option Payoff\")\n",
    "plt.axvline(S, color=\"gray\", linestyle=\"--\", label=\"Current Price\")\n",
    "plt.title(\"Option Payoff Diagram\")\n",
    "plt.xlabel(\"Stock Price (₹)\")\n",
    "plt.ylabel(\"Payoff (₹)\")\n",
    "plt.legend()\n",
    "plt.grid()\n",
    "st.pyplot(plt)\n",
    "\n",
    "# Implied Volatility Estimation\n",
    "market_price = st.sidebar.number_input(\"Market Option Price (₹)\", min_value=0.0, value=100.0, step=1.0)\n",
    "if market_price > 0:\n",
    "    iv = implied_volatility(S, K, T, r, market_price, option_type)\n",
    "    if iv is not None:\n",
    "        st.write(f\"The **Implied Volatility** is: {iv * 100:.2f}%\")\n",
    "    else:\n",
    "        st.error(\"Failed to calculate implied volatility. Check inputs.\")\n",
    "\n",
    "# Option Chain Data\n",
    "st.subheader(\"Live Option Chain Data\")\n",
    "if ticker:\n",
    "    call_data, put_data = fetch_option_chain(ticker.upper())\n",
    "    if call_data is not None:\n",
    "        st.write(\"**Call Options**\")\n",
    "        st.dataframe(call_data)\n",
    "        st.write(\"**Put Options**\")\n",
    "        st.dataframe(put_data)\n",
    "else:\n",
    "    st.error(\"Please enter a valid NSE stock ticker.\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "e75b720c-6156-4795-90bc-adb3080c0bde",
   "metadata": {},
   "outputs": [
    {
     "ename": "SyntaxError",
     "evalue": "unexpected character after line continuation character (293976196.py, line 1)",
     "output_type": "error",
     "traceback": [
      "\u001b[1;36m  Cell \u001b[1;32mIn[10], line 1\u001b[1;36m\u001b[0m\n\u001b[1;33m    C:\\Users\\Sachin D B\\Documents\\black_scholes_nse.py\u001b[0m\n\u001b[1;37m       ^\u001b[0m\n\u001b[1;31mSyntaxError\u001b[0m\u001b[1;31m:\u001b[0m unexpected character after line continuation character\n"
     ]
    }
   ],
   "source": [
    "C:\\Users\\Sachin D B\\Documents\\black_scholes_nse.py\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": None,
   "id": "d9771fe6-e491-4a10-9126-40e09f0eaf8e",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
